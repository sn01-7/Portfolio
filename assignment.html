<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Assignment</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <header>
        <h1>Assignment</h1>
        <nav>
            <ul>
                <li><a href="index.html">Home</a></li>
                <li><a href="#about">About</a></li>
                <li><a href="#projects">Projects</a></li>
                <li><a href="#contact">Contact</a></li>
            </ul>
        </nav>
    </header>

    <section id="project-details">
        <h2>Arithmetic Expression Evaluation</h2>
        <p>The stack organization is very effective in evaluating arithmetic expressions. Expressions are usually represented in what is known as Infix notation, in which each operator is written between two operands (i.e., A + B). With this notation, we must distinguish between ( A + B )*C and A + ( B * C ) by using either parentheses or some operator-precedence convention. Thus, the order of operators and operands in an arithmetic expression does not uniquely determine the order in which the operations are to be performed. </p>

        <h2>Code Snippet</h2>
        <pre><code>
            #include &lt;stdio.h&gt;
            #include &lt;stdlib.h&gt;
            #include &lt;string.h&gt;
            #include &lt;ctype.h&gt;
                
                #define MAX 100
                
                // Stack structure for operators
                typedef struct {
                    int top;
                    char items[MAX];
                } CharStack;
                
                // Function prototypes
                void pushChar(CharStack* s, char value);
                char popChar(CharStack* s);
                char peekChar(CharStack* s);
                int isEmptyChar(CharStack* s);
                int precedence(char op);
                void convertToPostfix(char* infix, char* postfix);
                void convertToPrefix(char* infix, char* prefix);
                void reverse(char* exp);
                
                // Stack operations
                void pushChar(CharStack* s, char value) {
                    if (s->top < MAX - 1) {
                        s->items[++(s->top)] = value;
                    }
                }
                
                char popChar(CharStack* s) {
                    if (!isEmptyChar(s)) {
                        return s->items[(s->top)--];
                    }
                    return '\0'; // return null character if empty
                }
                
                char peekChar(CharStack* s) {
                    if (!isEmptyChar(s)) {
                        return s->items[s->top]; // Return the top item without removing it
                    }
                    return '\0'; // Return null character if empty
                }
                
                int isEmptyChar(CharStack* s) {
                    return s->top == -1;
                }
                
                // Function to return precedence of operators
                int precedence(char op) {
                    switch (op) {
                        case '+':
                        case '-': return 1;
                        case '*':
                        case '/': return 2;
                        case '(': return 0;
                    }
                    return -1; // Invalid operator
                }
                
                // Reverse a string
                void reverse(char* exp) {
                    int n = strlen(exp);
                    for (int i = 0; i < n / 2; i++) {
                        char temp = exp[i];
                        exp[i] = exp[n - i - 1];
                        exp[n - i - 1] = temp;
                    }
                }
                
                // Convert infix expression to postfix
                void convertToPostfix(char* infix, char* postfix) {
                    CharStack operators;
                    operators.top = -1;
                    int j = 0;
                
                    for (int i = 0; infix[i]; i++) {
                        if (isspace(infix[i])) continue; // Ignore spaces
                
                        if (isalnum(infix[i])) {
                            postfix[j++] = infix[i];
                            postfix[j++] = ' '; // Space to separate variables
                        } else if (infix[i] == '(') {
                            pushChar(&operators, infix[i]);
                        } else if (infix[i] == ')') {
                            while (!isEmptyChar(&operators) && peekChar(&operators) != '(') {
                                postfix[j++] = popChar(&operators);
                                postfix[j++] = ' ';
                            }
                            popChar(&operators); // Remove '(' from stack
                        } else { // Operator
                            while (!isEmptyChar(&operators) && precedence(peekChar(&operators)) >= precedence(infix[i])) {
                                postfix[j++] = popChar(&operators);
                                postfix[j++] = ' ';
                            }
                            pushChar(&operators, infix[i]);
                        }
                    }
                
                    // Pop all operators
                    while (!isEmptyChar(&operators)) {
                        postfix[j++] = popChar(&operators);
                        postfix[j++] = ' ';
                    }
                    postfix[j] = '\0';
                }
                
                // Convert infix expression to prefix
                void convertToPrefix(char* infix, char* prefix) {
                    reverse(infix);
                    CharStack operators;
                    operators.top = -1;
                    int j = 0;
                
                    for (int i = 0; infix[i]; i++) {
                        if (isspace(infix[i])) continue;
                
                        if (isalnum(infix[i])) {
                            prefix[j++] = infix[i];
                            prefix[j++] = ' ';
                        } else if (infix[i] == ')') {
                            pushChar(&operators, infix[i]);
                        } else if (infix[i] == '(') {
                            while (!isEmptyChar(&operators) && peekChar(&operators) != ')') {
                                prefix[j++] = popChar(&operators);
                                prefix[j++] = ' ';
                            }
                            popChar(&operators);
                        } else {
                            while (!isEmptyChar(&operators) && precedence(peekChar(&operators)) > precedence(infix[i])) {
                                prefix[j++] = popChar(&operators);
                                prefix[j++] = ' ';
                            }
                            pushChar(&operators, infix[i]);
                        }
                    }
                
                    // Pop all operators
                    while (!isEmptyChar(&operators)) {
                        prefix[j++] = popChar(&operators);
                        prefix[j++] = ' ';
                    }
                    prefix[j] = '\0';
                    reverse(prefix);
                }
                
                // Main function
                int main() {
                    char expression[MAX];
                    char postfix[MAX];
                    char prefix[MAX];
                    int choice;
                
                    // Input expression
                    printf("Enter an arithmetic expression (e.g., A + B): ");
                    fgets(expression, MAX, stdin);
                    expression[strcspn(expression, "\n")] = 0;
                
                    // Convert to postfix and prefix
                    convertToPostfix(expression, postfix);
                    convertToPrefix(expression, prefix);
                
                    // User choice
                    printf("Choose output format:\n");
                    printf("1. Postfix\n");
                    printf("2. Prefix\n");
                    printf("Enter your choice (1 or 2): ");
                    scanf("%d", &choice);
                
                    // Output results
                    if (choice == 1) {
                        printf("Postfix: %s\n", postfix);
                    } else if (choice == 2) {
                        printf("Prefix: %s\n", prefix);
                    } else {
                        printf("Invalid choice!\n");
                    }
                
                    return 0;
                }
                
        </code></pre>

        <h2>Code Explanation</h2>
        <p>This code converts an arithmetic infix expression (like "A + B") into postfix (Reverse Polish Notation) and prefix (Polish Notation) expressions using a stack data structure. Hereâ€™s a detailed breakdown:</p>
        
        <h3>Structure of the Code</h3>
        
        <h4>1. Includes and Definitions</h4>
        <ul>
            <li>Standard C libraries are included for input/output, string manipulation, and character classification.</li>
            <li>A constant <code>MAX</code> is defined to set the maximum size of the expression and the stack.</li>
        </ul>
        
        <h4>2. Stack Structure (<code>CharStack</code>)</h4>
        <ul>
            <li>This structure holds characters, mainly operators and parentheses, with a fixed-size array of <code>MAX</code> elements.</li>
            <li>The <code>top</code> integer keeps track of the current top of the stack, initialized to <code>-1</code> to indicate an empty stack.</li>
        </ul>
        
        <h4>3. Stack Operations</h4>
        <ul>
            <li><code>pushChar</code>: Adds a character to the stack and increments the <code>top</code>.</li>
            <li><code>popChar</code>: Removes and returns the character at the top of the stack. Returns a null character (<code>'\0'</code>) if the stack is empty.</li>
            <li><code>peekChar</code>: Returns the character at the top of the stack without removing it.</li>
            <li><code>isEmptyChar</code>: Checks if the stack is empty by checking if <code>top</code> is -1.</li>
        </ul>
        
        <h4>4. Operator Precedence Function (<code>precedence</code>)</h4>
        <ul>
            <li>Returns an integer indicating operator precedence, where higher numbers mean higher precedence:</li>
            <ul>
                <li><code>+</code> and <code>-</code> have precedence 1.</li>
                <li><code>*</code> and <code>/</code> have precedence 2.</li>
                <li><code>(</code> has precedence 0 (used to control parentheses processing).</li>
            </ul>
            <li>Any unrecognized character is assigned precedence <code>-1</code>.</li>
        </ul>
        
        <h4>5. Expression Reversal Function (<code>reverse</code>)</h4>
        <ul>
            <li>Reverses a string in place, which is essential for converting an infix expression to prefix notation (Polish Notation).</li>
        </ul>
        
        <h4>6. Infix to Postfix Conversion (<code>convertToPostfix</code>)</h4>
        <p>Converts an infix expression (e.g., "A + B") to postfix notation (e.g., "A B +").</p>
        <ul>
            <li>A <code>CharStack</code> instance is used to store operators temporarily.</li>
            <li>Loop through each character in the infix expression:
                <ul>
                    <li><strong>Operands</strong> (like A, B, 1, etc.): Directly added to postfix along with a space for separation.</li>
                    <li><strong>Left Parenthesis</strong> <code>(</code>: Pushed onto the stack.</li>
                    <li><strong>Right Parenthesis</strong> <code>)</code>: Causes the stack to pop operators until a left parenthesis is encountered (the left parenthesis is discarded).</li>
                    <li><strong>Operators</strong> <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>: Popped from the stack and added to postfix if they have higher or equal precedence than the incoming operator. Then, the current operator is pushed onto the stack.</li>
                </ul>
            </li>
            <li>After the loop, any remaining operators in the stack are popped to postfix.</li>
        </ul>
        <p><strong>Result</strong>: The <code>postfix</code> array holds the postfix expression.</p>
        
        <h4>7. Infix to Prefix Conversion (<code>convertToPrefix</code>)</h4>
        <p>Converts an infix expression to prefix notation by first reversing the infix expression.</p>
        <ul>
            <li>The infix expression is reversed so that operators are processed in the correct order.</li>
            <li>The same stack-based logic as in <code>convertToPostfix</code> is applied, with minor adjustments to handle reversed parentheses.
                <ul>
                    <li><strong>Operands</strong>: Added to prefix.</li>
                    <li><strong>Left Parenthesis</strong> <code>(</code> and <strong>Right Parenthesis</strong> <code>)</code>: Their roles are swapped because of the reversed order.</li>
                    <li><strong>Operators</strong>: Checked for precedence and pushed or popped in a similar way as in postfix conversion.</li>
                </ul>
            </li>
            <li>After processing all characters, any remaining operators in the stack are popped to prefix.</li>
            <li>The final prefix expression is then reversed to correct its order.</li>
        </ul>
        <p><strong>Result</strong>: The <code>prefix</code> array contains the prefix expression.</p>
        
        <h4>8. Main Function</h4>
        <ul>
            <li><strong>Input</strong>: An arithmetic infix expression is taken from the user.</li>
            <li><strong>Conversion</strong>: <code>convertToPostfix</code> and <code>convertToPrefix</code> are called to generate both postfix and prefix forms of the expression.</li>
            <li><strong>User Choice and Output</strong>:
                <ul>
                    <li>The user is prompted to choose between postfix and prefix outputs.</li>
                    <li>Based on the choice, either postfix or prefix is printed.</li>
                </ul>
            </li>
        </ul>        
        
        <h2>The type of data structure used is Stack</h2>
        <h3>Live Demo</h3>
        <a href="https://www.onlinegdb.com/" target="_blank">View Live Demo</a>
    </section>

    <footer>
        <p>&copy; 2024 My Portfolio</p>
    </footer>
</body>
</html>
