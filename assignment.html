<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Assignment</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <header>
        <h1>Assignment</h1>
        <nav>
            <ul>
                <li><a href="index.html">Home</a></li>
                <li><a href="#about">About</a></li>
                <li><a href="#projects">Projects</a></li>
                <li><a href="#contact">Contact</a></li>
            </ul>
        </nav>
    </header>

    <section id="project-details">
        <h2>Arithmetic Expression Evaluation</h2>
        <p>The stack organization is very effective in evaluating arithmetic expressions. Expressions are usually represented in what is known as Infix notation, in which each operator is written between two operands (i.e., A + B). With this notation, we must distinguish between ( A + B )*C and A + ( B * C ) by using either parentheses or some operator-precedence convention. Thus, the order of operators and operands in an arithmetic expression does not uniquely determine the order in which the operations are to be performed. </p>

        <h3>Code Snippet</h3>
        <pre><code>
            #include &lt;stdio.h&gt;
            #include &lt;stdlib.h&gt;
            #include &lt;string.h&gt;
            #include &lt;ctype.h&gt;
                
                #define MAX 100
                
                // Stack structure for operators
                typedef struct {
                    int top;
                    char items[MAX];
                } CharStack;
                
                // Function prototypes
                void pushChar(CharStack* s, char value);
                char popChar(CharStack* s);
                char peekChar(CharStack* s);
                int isEmptyChar(CharStack* s);
                int precedence(char op);
                void convertToPostfix(char* infix, char* postfix);
                void convertToPrefix(char* infix, char* prefix);
                void reverse(char* exp);
                
                // Stack operations
                void pushChar(CharStack* s, char value) {
                    if (s->top < MAX - 1) {
                        s->items[++(s->top)] = value;
                    }
                }
                
                char popChar(CharStack* s) {
                    if (!isEmptyChar(s)) {
                        return s->items[(s->top)--];
                    }
                    return '\0'; // return null character if empty
                }
                
                char peekChar(CharStack* s) {
                    if (!isEmptyChar(s)) {
                        return s->items[s->top]; // Return the top item without removing it
                    }
                    return '\0'; // Return null character if empty
                }
                
                int isEmptyChar(CharStack* s) {
                    return s->top == -1;
                }
                
                // Function to return precedence of operators
                int precedence(char op) {
                    switch (op) {
                        case '+':
                        case '-': return 1;
                        case '*':
                        case '/': return 2;
                        case '(': return 0;
                    }
                    return -1; // Invalid operator
                }
                
                // Reverse a string
                void reverse(char* exp) {
                    int n = strlen(exp);
                    for (int i = 0; i < n / 2; i++) {
                        char temp = exp[i];
                        exp[i] = exp[n - i - 1];
                        exp[n - i - 1] = temp;
                    }
                }
                
                // Convert infix expression to postfix
                void convertToPostfix(char* infix, char* postfix) {
                    CharStack operators;
                    operators.top = -1;
                    int j = 0;
                
                    for (int i = 0; infix[i]; i++) {
                        if (isspace(infix[i])) continue; // Ignore spaces
                
                        if (isalnum(infix[i])) {
                            postfix[j++] = infix[i];
                            postfix[j++] = ' '; // Space to separate variables
                        } else if (infix[i] == '(') {
                            pushChar(&operators, infix[i]);
                        } else if (infix[i] == ')') {
                            while (!isEmptyChar(&operators) && peekChar(&operators) != '(') {
                                postfix[j++] = popChar(&operators);
                                postfix[j++] = ' ';
                            }
                            popChar(&operators); // Remove '(' from stack
                        } else { // Operator
                            while (!isEmptyChar(&operators) && precedence(peekChar(&operators)) >= precedence(infix[i])) {
                                postfix[j++] = popChar(&operators);
                                postfix[j++] = ' ';
                            }
                            pushChar(&operators, infix[i]);
                        }
                    }
                
                    // Pop all operators
                    while (!isEmptyChar(&operators)) {
                        postfix[j++] = popChar(&operators);
                        postfix[j++] = ' ';
                    }
                    postfix[j] = '\0';
                }
                
                // Convert infix expression to prefix
                void convertToPrefix(char* infix, char* prefix) {
                    reverse(infix);
                    CharStack operators;
                    operators.top = -1;
                    int j = 0;
                
                    for (int i = 0; infix[i]; i++) {
                        if (isspace(infix[i])) continue;
                
                        if (isalnum(infix[i])) {
                            prefix[j++] = infix[i];
                            prefix[j++] = ' ';
                        } else if (infix[i] == ')') {
                            pushChar(&operators, infix[i]);
                        } else if (infix[i] == '(') {
                            while (!isEmptyChar(&operators) && peekChar(&operators) != ')') {
                                prefix[j++] = popChar(&operators);
                                prefix[j++] = ' ';
                            }
                            popChar(&operators);
                        } else {
                            while (!isEmptyChar(&operators) && precedence(peekChar(&operators)) > precedence(infix[i])) {
                                prefix[j++] = popChar(&operators);
                                prefix[j++] = ' ';
                            }
                            pushChar(&operators, infix[i]);
                        }
                    }
                
                    // Pop all operators
                    while (!isEmptyChar(&operators)) {
                        prefix[j++] = popChar(&operators);
                        prefix[j++] = ' ';
                    }
                    prefix[j] = '\0';
                    reverse(prefix);
                }
                
                // Main function
                int main() {
                    char expression[MAX];
                    char postfix[MAX];
                    char prefix[MAX];
                    int choice;
                
                    // Input expression
                    printf("Enter an arithmetic expression (e.g., A + B): ");
                    fgets(expression, MAX, stdin);
                    expression[strcspn(expression, "\n")] = 0;
                
                    // Convert to postfix and prefix
                    convertToPostfix(expression, postfix);
                    convertToPrefix(expression, prefix);
                
                    // User choice
                    printf("Choose output format:\n");
                    printf("1. Postfix\n");
                    printf("2. Prefix\n");
                    printf("Enter your choice (1 or 2): ");
                    scanf("%d", &choice);
                
                    // Output results
                    if (choice == 1) {
                        printf("Postfix: %s\n", postfix);
                    } else if (choice == 2) {
                        printf("Prefix: %s\n", prefix);
                    } else {
                        printf("Invalid choice!\n");
                    }
                
                    return 0;
                }
                
        </code></pre>
        
        <h3>The type of data structure used is Stack</h3>
        <h3>Live Demo</h3>
        <a href="https://www.onlinegdb.com/" target="_blank">View Live Demo</a>
    </section>

    <footer>
        <p>&copy; 2024 My Portfolio</p>
    </footer>
</body>
</html>
